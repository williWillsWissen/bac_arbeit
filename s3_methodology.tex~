%-------------------------------------------------------
% Methodology
%-------------------------------------------------------
\section{Methodology}
\label{sec:methodology}

%----------------------------------------------
% * Verwendetet Technologien
%----------------------------------------------
\subsection{Verwendetet Technologien und Protokolle}
\label{sec:Verwendetet Technologien}

%----------------------------------------------
% ** HTTP
%----------------------------------------------
\subsubsection{HTTP}
\label{sec:HTTP}

HTTP (Hyper Text Transfer Protokoll) ist ein Protokoll zur übertragung von Daten über ein Netzwerk welches auf TCP aufsetzt.
Der Datenaustausch zwischen zwei Kommunikationspartner findet in der From von Nachrichten statt, 
wobei der Client eine Anfrage an einen Server stellt und dieser die Anfrage bearbeitet und eine Antwort retuniert.
\\
Eine Nachricht setzt sich aus einem Header und einen Body zusammen.
Der Body enthält die Nutzdaten und der Header enthält Metadaten über die Nutzdaten.
Vom Aufbau der Nachricht unterscheiden sich Anfrage und Antwort nur in der ersten Zeile:
\begin{itemize}
	\item Anfrage: Enthält die HTTP-Methode, die URL welche auf die Resource am Server zeigt und die Protokollversion.
	\item Antwort: Enthält die Protokollversion und den Serverstatus. 
		Der Serverstatus liefert eine Aussage ob der Request erfolgreich bearbeitet wurde bzw welche Art von Fehler bei der Bearbeitung aufgetreten ist.
\end{itemize}
HTTP ist ein zustandsloses Protokoll, daher wird nach jeder Anfrage die Verbindung vom Server wieder abgebaut.
Für eine Zuordnung eines Clients muss dieser eine Session-ID mitsenden welche normalerweise im Header enthalten ist.
% TODO: RFC zietieren

%--------------------------------------------- 
% ** REST
%----------------------------------------------
\subsubsection{REST}
\label{sec:HTTP}
REST ist im eigentlichen Sin mehr ein Architekturstiel als ein Protokoll welcher mit HTTP umgesetzt wird.
Die Idee von REST ist dass eine URL genau eine Resource auf einem Server addressiert, 
wobei eine Resource eine statische Datei oder das ergebniss einer aktion auf dem Server sein kann.
\\
Der Architekturstiel ist lässt sich durch fünf Prizipien zusammenfassen:
\\
\\
\textbf{Resource mit eindeutiger Identifikation:}\\
Jede Resrouce wird durch eine URI (Uniform Resouce Identifier) weltweit eindeutig identifiziert.
Diese addressiert unter anderem den Server auf den sich die resource befindet sowie Resource auf dem Server selbst.
\\
\\
\textbf{Hypermedia}\\
Verknüfungen zu anderen Entitäten und werden als Links auf die jeweiligen Resourcen dargestellt.
Weiters kann die Steuertung des Applikationszustandes durch Links auf weiter Aktionen durch Hypermedia umgesetzt werden.
\\
\\
\textbf{Standard-Opperationen}\\
Es gibt ein definiertes Interface welches von jeder Resource zur verfügung gestellt werden muss.
Dieses umfasst einen relativ kleinen Satz von Opperationen welche auf die Resource ausgeführt werden können.
\\
\\
\textbf{Unterschiedliche repräsentation der Resourcen}\\
Die Resourcen können unterschiedliche Darstellungsformen haben.
Ein Client kann also eine Resource in einem bestimmten Format (z.B.: XML, HTML, JSON) anfordern sofern diese Darstellung vom Server unterstüzt wird.
In HTTP wird die gewünschte Dartstellung im Header angegeben.
\\
\\
\textbf{Zustandslose Kommunikation}\\
Der Server hällt keine Zustandsinformationen über den Client welcher über die Dauer eines Requests hinaus geht.
Daher muss der Zustand einer Anwendung entweder am Client liegen oder vom Server in eine Resource umgewandelt werden.
%----------------------------------------------
% ** JSON
%----------------------------------------------
\subsubsection{JSON}
\label{sec:JSON}
Bei JSON (JavaScript Object Notation) handelt es sich um ein Datenformat zum Autausch von Arrays und Objekt-Graphen.
JSON findet neben XML vorallem in der Kommunikation zwischen Client und Server bei Webanwendungen Verwendung, 
wobei JSON Daten wesentlich kompakter und damit Resourcensparender sind.
Wie bei XML werden Listen und Objekte in einer von Menschen lesbaren Form darestellt.
\\
Dabei werden folgende Datentypen unterstützt welche wiederum beliebig tief ineinander Verschachtelt werden können: NULL, Boolean, Zahl, String, Array und Objekt.


%----------------------------------------------
% ** AJAX
%----------------------------------------------
\subsubsection{AJAX}
\label{sec:AJAX}
AJAX (Asynchronous JavaScript and XML) ermöglicht es einer Webanwendung kleinere Mengen von Daten nachzuladen und damit Teile der Webseite dynamisch zu ändern, 
statt bei jeder Aktion die Webseite neu zu laden.
\\
Benötigt die Web Appliketion Daten vom Server wird an diesem eine HTTP Anfrage gesendet und Callback-Funktionen für den Fall einer Antwort oder eines Fehlers beim Browser registriert.
Erhällt der Browser eine Antwort auf sine Anfrage ruft er die Callback-Funktion auf und übergibt die erhalten Daten wodurch die Webanwendung mit der Verarbeitung dieser fortfahren kann.
\\
Dies ermöglicht die Entwicklung komplexer Webapplikationen, wobei die Webapplikation selbst mit der Seite geladen wird und die Daten die der Benutzer mit der Anwendung verarbeiten möchte dynamisch von dieser nachgeladen werden können.

%----------------------------------------------
% ** Objectiv J
%----------------------------------------------
\subsubsection{Objectiv J}
\label{sec:Objectiv J}

Objective J ist eine Programmiersprache welche sich von der Syntax stark an Objective C anlehnt.
Sie ist eine Erweiterung oder Obermenge von Javascript und wird von einem in Javascript geschriebenen Interpreter abgearbeitet.
In Javascript können Objekte durch Prototyping erstellt werden, das Konzept von Klassen wird aber nicht unterstüzt.
Obj J bietet zusätzlich zu den nativen JS Objekten die definition von Klassen inklusive Vererbung und die generierung von Objekten daraus.
Obwohl es die Sprache erlaubt für Variablen, Methodenparameter und Rückgaben eine Datentyp zu definieren, 
werden diese aufgrund von schwacher Typisierung vom Interpreter nicht auf ihre Einhaltung überprüft.
In der aktullen Version wird die Übergabe von Referenzen als Parameter ähnlich einem Pointer in C unterstützt.
\cite{capp}

%----------------------------------------------
% ** Cappuccino
%----------------------------------------------
\subsubsection{Cappuccino}
\label{sec:Cappuccino}
Bei Cappuccino handelt es sich um ein Web Application Framework für Objectiv J und Javascript, welches haupsächlich der Erstellung komplexer Benutzeroberflächen dient.
Das Framework lehnt sich sowol vom Aussehen als auch von der Benennung der Komponenten sehr stark an das GUI-Framework Cocoa von Apple an.
GUI-Elemente werden als Objekte erstellt welche von einer View-Klasse erben und innerhalb von anderen Views positioniert werden können.
Das Interface wird von einem HTML5 fähigen Browser gerendert wobei für dessen Erstellung keinerlei HTML oder CSS kentnisse notwendig sind.


%----------------------------------------------
% ** WebGL 
%----------------------------------------------
\subsubsection{WebGL}
\label{sec:WebGL}
WebGL ist eine API für die Erstellung von 2D und 3D Grafiken in Browsern mit der Unterstützung der Grafikkarte.
Im gegensatz zur Canvas-2D API wo die Bilder in der CPU gerendert werden, ist WebGL aufgrund der Hardwarebeschleunigung wesentlich performanter.
\\
WebGL ist eine Shaderbasierte API welche sich sehr stark an OpenGL ES anlehnt.
Diese bedeutet dass Code für die Recheneinheiten (Shadereinheiten) der Grafikkarte entwickelt wird,
welchen der Treiber der Karte in Bytecode übersetzt und zur ausführung in den Grafikchip lädt.
Die Shaderprogramme werden in der Programmiersprache GLSL geschrieben welche sich sehr stark an C anlehnt.
\\
Der Zugriff auf die Schnittstelle erfolgt über das HTML Canvas Element in welchem die Ausgabe der Grafikkarte dargestellt wird.
Dies geschieht mittels JavaScript wo die API funktionen zur Übergabe der Nutzdaten, Befehle und der Shaderprogramme bereitstellt.



%----------------------------------------------
% * Kommunikation mit KRESHMOI
%----------------------------------------------
\subsection{Kommunikation mit KRESHMOI}
\label{sec:Kommunikation mit KRESHMOI}
Der Datenaustausch mit KRESHMOI basiert auf REST wobei sowohl auf die einzelnen Slices von einem Volume, als auch auf die Suche als Resoure über eine URL zugegrifen werden kann.

%----------------------------------------------
% ** Query nach Bildern
%----------------------------------------------
\subsubsection{Query nach Bildern}
\label{sec:Query nach Bildern}
Der Zugriff auf die Suchfunktion erfolgt über ein POST wobei sowohl in der Anfrage als auch in der Antwort die Daten in JSON codiert werden.
Zum stellen einer Suchanfrage stehen zwei Resourcen zur verfügung:
\\
\textit{/index}\\
Liefert ein Array von allen Verfügbaren Datensätzen zurück 
\\
\\
\textit{/query}\\
Liefert ein Array von Datensätzen zurück welche anhand der Übergebenen Daten gefunden wurden.
Eine Suchanfrage basiert immer auf einen Datensatz welcher in der Anfrage übergeben werden muss.
In diesem Datensatz werden weiters Interessante Bereiche sogenannte ROIs (Region of Interesst) in den einzelnen Schnittbildern definiert.
Die Übergabe einer ROI erfolgt als Polygon in Form einer Listen von Punkten im drei Dimensionalen Raum des Volumes.
\begin{lstlisting}[language=json,firstnumber=1]
{
   "queryid":"",
   "text":"",
   "imageid":"",
   "roi": 
   [
      "polygon":
      [
         "point":{"x":0, "y":0, z:0},
      ],

   ]
}
\label{json-example}
\end{lstlisting}


\begin{lstlisting}[language=json,firstnumber=1]
{
   "rankedImageID": 
   [
      {
         "imageID": "9587336b132b127b936ad0afd80ca862",
         "normalDimX": 1,
         "normalDimY": 380,
         "normalDimZ": 488,
         "relevance": 1,
         "report": "",
         "title": "Some Image"
      },
   ]
}
\end{lstlisting}
%----------------------------------------------
% ** Laden der Bilder
%----------------------------------------------
\subsubsection{Laden der Bilder}
\label{sec:Laden der Bilder}


%----------------------------------------------
% * Architektur und Komponenten
%----------------------------------------------
\subsection{Architektur und Komponenten}
\label{sec:Architektur und Komponenten}

%----------------------------------------------
% ** Domänen Model
%----------------------------------------------
\subsubsection{Domänen Model}
\label{sec:Domänen Model}

%----------------------------------------------
% ** Architektur und Aufteilung in Komponenten
%----------------------------------------------
\subsubsection{Architektur und Aufteilung in Komponenten}
\label{sec:Architektur und Aufteilung in Komponenten}

%----------------------------------------------
% ** 2DView
%----------------------------------------------
\subsubsection{2DView}
\label{sec:2DView}

%----------------------------------------------
% ** Kommunikations Module
%----------------------------------------------
\subsubsection{Kommunikations Module}
\label{sec:Kommunikations Module}

%----------------------------------------------
% * Usability
%----------------------------------------------
\subsection{Usability}
\label{sec:Usability}

%----------------------------------------------
% ** Workflow bei der Befundung
%----------------------------------------------
\subsubsection{Workflow bei der Befundung}
\label{sec:Workflow bei der Befundung}

